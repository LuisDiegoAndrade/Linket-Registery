<!DOCTYPE html>
<html>
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU"
       crossorigin="anonymous">

    <link href="https://fonts.googleapis.com/css?family=Baskervville&display=swap" rel="stylesheet">

    {% if title %}
        <title>[Linket] - {{ title }}</title>
    {% else %}
        <title>[Linket]</title>
    {% endif %}

    {% if current_user.is_authenticated %}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js" integrity="sha256-bQmrZe4yPnQrLTY+1gYylfNMBuGfnT/HKsCGX+9Xuqo=" crossorigin="anonymous"></script>
    {% endif %}
</head>
<body>
    <header class="site-header">
      <nav class="navbar navbar-expand-md navbar-light bg-steel fixed-top">
        <div class="container">
          <img class="navbar-brand mr-4" src="http://linket.info/wp-content/uploads/2019/02/logo.png">
          <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarToggle" aria-controls="navbarToggle" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarToggle">
            <div class="navbar-nav mr-auto">
              {% if current_user.is_authenticated %}
              <a class="nav-item nav-link" href="/dashboard">Dashboard</a>
              <a class="nav-item nav-link" href="/dashboard">Explore</a>
              {% else %}
              <a class="nav-item nav-link" href="/login">Home</a>
              <a class="nav-item nav-link" href="/login">About</a>
              {% endif%}
            </div>
            <!-- Navbar Right Side -->
            <div class="navbar-nav">
              {% if not current_user.is_authenticated %}
              <a class="nav-item nav-link" href="/login">Login</a>
              <a class="nav-item nav-link" href="/signup">Signup</a>
              {% endif %}
              {% if current_user.is_authenticated %}
              <a class="nav-item nav-link" href="/signout">Logout</a>
              {% endif %}
            </div>
          </div>
        </div>
      </nav>
    </header>
    <main role="main" class="container">
      <div class="row">
        <div class="col-md-8">
          {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages%}
              {% for category, message in messages %}
                <div class="alert alert-{{ category }}">
                  {{ message }}
                </div>
              {% endfor %}
            {% endif%}
          {% endwith %}
          {% block content %}{% endblock %}
        </div>


          {% if not current_user.is_authenticated %}
          <div class="col-md-4">
            <div class="content-section">
              <br>
              <h3>[ Linket ]</h3>
              <p class='text-muted'>beta
                <img style="width: 171px; height: 156px" src="https://linket.info/wp-content/uploads/2019/06/small-linkcat.jpg"/>
              </p>
            </div>
          </div>
          {% else %}
          <div class="col-md-4">
            <div class="content-section">
              <br>
              <h3>{{current_user.username}}</h3>
              <p class='text-muted'>Select an option
                <ul class="list-group">
                  <li style="margin: 0px 0px 5px 0px" class="btn btn-outline-info" onclick="window.location ='/dashboard/registerlinket'">Get a Linket</li>
                  <li style="margin: 0px 0px 5px 0px" class="btn btn-outline-info">My deeplinks</li>
                </ul>
              </p>
            </div>
          </div>
          {% endif %}



        </div>



      </div>
    </main>


    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    {% if current_user.is_authenticated %}
      <script src="{{url_for("static", filename="app.js")}}"></script>
    {% endif %}

    <!-- This script will be moved to an appropiate path once finsished -->
    {% if current_user.is_authenticated %}
      <script>

        'use strict';

        let targetedUser = null;
        let pc = null;
        let me = null;
        let sending_channel = null;
        let receiving_channel = null;

        async function getUsername() {
          const res = await fetch("./getusername", {method:"post"});
          const json = await res.json();
          me = json.username;
        } getUsername();

        function messageServer(msgObj){
          socket.send(JSON.stringify(msgObj));
        }

        async function makePeerConnection() {
          console.log("Creating peer connection!");
          pc = new RTCPeerConnection( {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]} );
          pc.onicecandidate = handleICECandidateEvent;
          pc.onnegotiationneeded = handleNegotiationNeededEvent;
          //pc.oniceconnectionstatechange = #Add E.H if needed;
          //pc.onicegatheringstatechange = # Add E.H if needed;

        }


        async function handleNegotiationNeededEvent() {
          try {

            console.log("handleNegotiationNeededEvent executing!")
            const offer = await pc.createOffer();

            if (pc.signalingState != "stable") {
              console.log("Connection is not stable yet.")
              return;
            }

            await pc.setLocalDescription(offer);

            messageServer( {type: "channel-offer", sender: me, target: targetedUser, sdp: pc.localDescription} );


          } catch(err){
            console.log(err);
          };
        }

        function handleICECandidateEvent(event) {
            if (event.candidate) {
              console.log(event.candidate);
              messageServer( {type: "new-ice-candidate", target: targetedUser, candidate: event.candidate} );
            }
        }

        async function handleChannelOffer(msg) {
          if (!window.confirm("Connect to " + msg.sender + "?")) {
            alert("Connection denied!");
            return;
          }
          if(!pc) {
            makePeerConnection();
            pc.ondatachannel = receiveChannelCallback;
          }

          let description = new RTCSessionDescription(msg.sdp);

          // If the connection isn't stable yet, wait for it...
          if (pc.signalingState != "stable") {
            console.log("Signaling state isn't stable, so triggering rollback.");

            // Set the local and remove descriptions for rollback; don't proceed
            // until both return.
            await Promise.all([
              pc.setLocalDescription({type: "rollback"}),
              pc.setRemoteDescription(description)
            ]);
            return;
          } else {
            console.log ("Setting remote description!");
            await pc.setRemoteDescription(description);
          }

          console.log("Creating and sending answer to caller.");
          await pc.setLocalDescription(await pc.createAnswer());

          messageServer( {type: "channel-answer", sender: me, target: msg.sender, sdp: pc.localDescription} );


        }

        async function handleChannelAnswer(msg) {
          console.log("Call recipient has accepted our call! (" + msg.sender + ")");

          // Configure the remote description, which is the SDP payload
          // in our "channel-answer" message.

          let description = new RTCSessionDescription(msg.sdp);
          await pc.setRemoteDescription(description).catch((err) => console.log(err));


        }

        async function handleNewICECandidate(msg) {
          let candidate = new RTCIceCandidate(msg.candidate);

          console.log("Adding received ICE candidate: " + JSON.stringify(candidate));
          try {
            await pc.addIceCandidate(candidate)
          } catch(err) {
            console.log(err)
          }
        }

        function senderChannelStatusChange(event) {
          if (sending_channel){
            if(sending_channel.readyState === "open") {
              alert("Peer opened data channel!");
              document.getElementById('chat').style.display = 'block';
              document.getElementById('connect').style.display = 'none';

              let chat = document.getElementById('chat');
              chat.addEventListener('submit', (e) => {
                e.preventDefault();
                let data = new FormData(chat);
                sending_channel.send(data.get('msg'))
                let msg = document.createElement('p');
                msg.setAttribute('class', 'alert alert-info alert-dismissible');
                msg.textContent = data.get('msg');
                document.getElementById('chatBox').appendChild(msg);

              });

            }
            else {
              alert("Peer closed data channel!");
            }
          }
        }

        function receiveChannelCallback(event) {
          receiving_channel = event.channel;
          receiving_channel.onmessage = receiveMessage;
          receiving_channel.onopen = handleReceiveChannelStatusChange;
          receiving_channel.onclose = handleReceiveChannelStatusChange;
        }

        function receiveMessage(event) {
          alert("Peer says: " + event.data);
          let msg = document.createElement('p');
          msg.setAttribute('class', 'alert alert-danger');
          msg.textContent = event.data;
          document.getElementById('chatBox').appendChild(msg);

        }

        function handleReceiveChannelStatusChange() {
          if(receiving_channel.readyState === "open") {
            alert("Ready to chat!");
            document.getElementById('chat').style.display = 'block';
            document.getElementById('connect').style.display = 'none';

            let chat = document.getElementById('chat');
            chat.addEventListener('submit', (e) => {
              e.preventDefault();
              let data = new FormData(chat);
              receiving_channel.send(data.get('msg'));
              let msg = document.createElement('p');
              msg.setAttribute('class', 'alert alert-info alert-dismissible');
              msg.textContent = data.get('msg');
              document.getElementById('chatBox').appendChild(msg);

            });
          }
          else {
            alert("Peer closed data channel!");
          }
        }


        let socket = io(window.location.protocol + "//" + window.location.hostname + ":" + window.location.port);
        socket.on('connect', () => {
          console.log("Connected to WS server!");

          // Add UI to allow "active / inactive" status
          //For now all connections are in an "active" state
          //Let the server know who you are
          socket.emit("New Connection", JSON.stringify( {status: "active"} ) );
        });



        //Handle messages from ws server
        socket.on('message', (data) => {
          console.log("Message from signaling server!")
          data = JSON.parse(data);

          switch (data.type) {
            case 'channel-offer':
              handleChannelOffer(data);
              break;

            case 'channel-answer':
              handleChannelAnswer(data);
              break;

            case 'new-ice-candidate':
              handleNewICECandidate(data);
              break;

          }
        });


        let connect = document.getElementById('connect');
        connect.addEventListener('submit', (e) => {
          e.preventDefault();

          let data = new FormData(connect);
          targetedUser = data.get('target');
          makePeerConnection();
          sending_channel = pc.createDataChannel("data-channel");
          sending_channel.onmessage = receiveMessage;
          sending_channel.onopen = senderChannelStatusChange;
          sending_channel.onclose = senderChannelStatusChange;

        });


      </script>
    {% endif %}

</body>
</html>
